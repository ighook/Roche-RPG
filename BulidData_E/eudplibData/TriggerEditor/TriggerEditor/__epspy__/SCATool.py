## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import SCAFlexible as scf;
import SCAFlexible as scf
# (Line 2) import TriggerEditor.SCArchive as sca;
from TriggerEditor import SCArchive as sca
# (Line 4) const CommandLength = 12;
CommandLength = _CGFW(lambda: [12], 1)[0]
# (Line 9) const ackMax = 0x20;
ackMax = _CGFW(lambda: [0x20], 1)[0]
# (Line 10) const MapDim = 0x600;
MapDim = _CGFW(lambda: [0x600], 1)[0]
# (Line 11) var DisConnectCode = 0xFFFF;
DisConnectCode = EUDCreateVariables(1)
_IGVA([DisConnectCode], lambda: [0xFFFF])
# (Line 14) var MSQCSpecial = 0;
MSQCSpecial = EUDCreateVariables(1)
_IGVA([MSQCSpecial], lambda: [0])
# (Line 15) var MSQCCondiction = 0;
MSQCCondiction = EUDCreateVariables(1)
_IGVA([MSQCCondiction], lambda: [0])
# (Line 16) var MSQCValue = 0;
MSQCValue = EUDCreateVariables(1)
_IGVA([MSQCValue], lambda: [0])
# (Line 18) const MSQCSpecialBuffer = PVariable();
MSQCSpecialBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 19) const MSQCBuffer = PVariable();
MSQCBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 20) const mappath = Db(260 + 8 * 4);
mappath = _CGFW(lambda: [Db(260 + 8 * 4)], 1)[0]
# (Line 21) function Init(){
@EUDFunc
def Init():
    # (Line 22) EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial);
    EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial)
    # (Line 23) EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer);
    EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer)
    # (Line 24) EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction);
    EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction)
    # (Line 25) EUDRegisterObjectToNamespace("MSQCValue", MSQCValue);
    EUDRegisterObjectToNamespace("MSQCValue", MSQCValue)
    # (Line 26) EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer);
    EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer)
    # (Line 28) dwwrite_epd(EPD(mappath) + 0, 3722075717);
    f_dwwrite_epd(EPD(mappath) + 0, 3722075717)
    # (Line 29) dwwrite_epd(EPD(mappath) + 1, 3982906636);
    f_dwwrite_epd(EPD(mappath) + 1, 3982906636)
    # (Line 30) dwwrite_epd(EPD(mappath) + 2, 1185060405);
    f_dwwrite_epd(EPD(mappath) + 2, 1185060405)
    # (Line 31) dwwrite_epd(EPD(mappath) + 3, 2930803196);
    f_dwwrite_epd(EPD(mappath) + 3, 2930803196)
    # (Line 32) dwwrite_epd(EPD(mappath) + 4, 773278115);
    f_dwwrite_epd(EPD(mappath) + 4, 773278115)
    # (Line 33) dwwrite_epd(EPD(mappath) + 5, 3579781808);
    f_dwwrite_epd(EPD(mappath) + 5, 3579781808)
    # (Line 34) dwwrite_epd(EPD(mappath) + 6, 3074824624);
    f_dwwrite_epd(EPD(mappath) + 6, 3074824624)
    # (Line 35) dwwrite_epd(EPD(mappath) + 7, 3414833178);
    f_dwwrite_epd(EPD(mappath) + 7, 3414833178)
    # (Line 36) f_repmovsd_epd(EPD(mappath) + 8, EPD(0x57FD3C), 65);
    f_repmovsd_epd(EPD(mappath) + 8, EPD(0x57FD3C), 65)
    # (Line 37) }
    # (Line 40) var SCAUseUserMessage = 1;

SCAUseUserMessage = EUDCreateVariables(1)
_IGVA([SCAUseUserMessage], lambda: [1])
# (Line 41) const SCALastMessage = PVariable();
SCALastMessage = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 58) var LastTick;
LastTick = EUDVariable()
# (Line 61) const ConnectStatus = PVariable();
ConnectStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 62) const MaxBuffer = PVariable();
MaxBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 63) const BaseAddrEPD = PVariable();
BaseAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 64) const LoadAddrEPD = PVariable();
LoadAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 65) var index;
index = EUDVariable()
# (Line 66) const rn = PVariable();
rn = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 67) const ack = PVariable();
ack = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 68) const SCACommand = PVariable();
SCACommand = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 69) const DataSlot = PVariable();
DataSlot = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 70) function ReceiveValue(value){
@EUDFunc
def ReceiveValue(value):
    # (Line 71) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 72) value = value % 0x10000 + (value / 0x10000) * MapDim;
    value << (value % 0x10000 + (value // 0x10000) * MapDim)
    # (Line 73) ack[CP] = value / 0x10000;
    _ARRW(ack, CP) << (value // 0x10000)
    # (Line 74) value = value % 0x10000;
    value << (value % 0x10000)
    # (Line 75) return value;
    EUDReturn(value)
    # (Line 76) }
    # (Line 78) function SendValue(seq){

@EUDFunc
def SendValue(seq):
    # (Line 79) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 80) const rseq = seq - 1;
    rseq = seq - 1
    # (Line 81) var value = wread_epd(BaseAddrEPD[CP] + rseq / 2, (rseq % 2) * 2);
    value = EUDVariable()
    value << (f_wread_epd(BaseAddrEPD[CP] + rseq // 2, (rseq % 2) * 2))
    # (Line 83) seq = seq % ackMax + 1;
    seq << (seq % ackMax + 1)
    # (Line 84) value += seq * 0x10000;
    value.__iadd__(seq * 0x10000)
    # (Line 86) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 87) MSQCValue = value % MapDim + (value / MapDim) * 0x10000;
        MSQCValue << (value % MapDim + (value // MapDim) * 0x10000)
        # (Line 88) }
        # (Line 89) }
    EUDEndIf()
    # (Line 95) const DateLoadStatus = PVariable();

DateLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 96) const GlobalDataLoadStatus = PVariable();
GlobalDataLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 101) function LoadDataRead(dataLen){
@EUDFunc
def LoadDataRead(dataLen):
    # (Line 102) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 104) switch(SCACommand[CP]){
    EUDSwitch(SCACommand[CP])
    # (Line 105) case 1:
    _t1 = EUDSwitchCase()
    # (Line 106) for(var i = 0 ; i < scf.ObjectCount; i++){
    if _t1(1):
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= scf.ObjectCount, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 107) scf.ResetValue(i, 0);
            scf.ResetValue(i, 0)
            # (Line 108) }
            # (Line 110) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= dataLen, neg=True):
            def _t5():
                i.__iadd__(1)
            # (Line 111) i = scf.LoadDataReadValue(LoadAddrEPD[CP], i);
            i << (scf.LoadDataReadValue(LoadAddrEPD[CP], i))
            # (Line 139) }
            # (Line 140) break;
            EUDSetContinuePoint()
            _t5()
        EUDEndWhile()
        EUDBreak()
        # (Line 141) case 2:
    _t6 = EUDSwitchCase()
    # (Line 143) const BaseAddres = LoadAddrEPD[CP];
    if _t6(2):
        BaseAddres = LoadAddrEPD[CP]
        # (Line 145) const aYM = dwread_epd(BaseAddres);
        aYM = f_dwread_epd(BaseAddres)
        # (Line 146) sca.Year = aYM / 0x10;
        _ATTW(sca, 'Year') << (aYM // 0x10)
        # (Line 147) sca.Month = aYM % 0x10;
        _ATTW(sca, 'Month') << (aYM % 0x10)
        # (Line 149) sca.Day = bread_epd(BaseAddres + 1, 3);
        _ATTW(sca, 'Day') << (f_bread_epd(BaseAddres + 1, 3))
        # (Line 150) sca.Hour = bread_epd(BaseAddres +1, 2);
        _ATTW(sca, 'Hour') << (f_bread_epd(BaseAddres + 1, 2))
        # (Line 151) sca.Min = bread_epd(BaseAddres + 1, 1);
        _ATTW(sca, 'Min') << (f_bread_epd(BaseAddres + 1, 1))
        # (Line 152) sca.Week = bread_epd(BaseAddres + 1 , 0);
        _ATTW(sca, 'Week') << (f_bread_epd(BaseAddres + 1, 0))
        # (Line 154) DateLoadStatus[CP] = 1;
        _ARRW(DateLoadStatus, CP) << (1)
        # (Line 155) break;
        EUDBreak()
        # (Line 156) case 3:
    _t7 = EUDSwitchCase()
    # (Line 158) var value = 0;
    if _t7(3):
        value = EUDVariable()
        value << (0)
        # (Line 160) for(var i = 0 ; i < 20; i++){
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= 20, neg=True):
            def _t9():
                i.__iadd__(1)
            # (Line 161) sca.GlobalData[i] = 0;
            _ARRW(sca.GlobalData, i) << (0)
            # (Line 162) }
            # (Line 164) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t9()
        EUDEndWhile()
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= dataLen, neg=True):
            def _t11():
                i.__iadd__(1)
            # (Line 165) const insepector = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
            insepector = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
            # (Line 166) if (insepector != 0){
            if EUDIf()(insepector == 0, neg=True):
                # (Line 167) const vsize = insepector / 0x100;
                vsize = insepector // 0x100
                # (Line 168) const index = insepector % 0x100;
                index_1 = insepector % 0x100
                # (Line 171) if (vsize == 1){
                if EUDIf()(vsize == 1):
                    # (Line 172) i++;
                    i.__iadd__(1)
                    # (Line 173) const value1 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value1 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 174) i++;
                    i.__iadd__(1)
                    # (Line 175) const value2 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value2 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 176) value = value1 * 0x10000 + value2;
                    value << (value1 * 0x10000 + value2)
                    # (Line 177) }else if(vsize == 2){
                if EUDElseIf()(vsize == 2):
                    # (Line 178) i++;
                    i.__iadd__(1)
                    # (Line 179) value = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value << (f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2))
                    # (Line 180) }
                    # (Line 182) sca.GlobalData[index] = value;
                EUDEndIf()
                _ARRW(sca.GlobalData, index_1) << (value)
                # (Line 183) }
                # (Line 186) }
            EUDEndIf()
            # (Line 187) GlobalDataLoadStatus[CP] = 1;
            EUDSetContinuePoint()
            _t11()
        EUDEndWhile()
        _ARRW(GlobalDataLoadStatus, CP) << (1)
        # (Line 188) break;
        EUDBreak()
        # (Line 189) }
    # (Line 190) }
    EUDEndSwitch()
    # (Line 193) function SaveDataWrite(){

@EUDFunc
def SaveDataWrite():
    # (Line 194) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 195) var index = 0;
    index_1 = EUDVariable()
    index_1 << (0)
    # (Line 197) for(var i = 0 ; i < scf.ObjectCount; i++){
    i = EUDVariable()
    i << (0)
    if EUDWhile()(i >= scf.ObjectCount, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 198) index = scf.SaveDataWriteValue(i,BaseAddrEPD[CP],index);
        index_1 << (scf.SaveDataWriteValue(i, BaseAddrEPD[CP], index_1))
        # (Line 220) }
        # (Line 221) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 222) index++;
    index_1.__iadd__(1)
    # (Line 223) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 224) index++;
    index_1.__iadd__(1)
    # (Line 225) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 226) index++;
    index_1.__iadd__(1)
    # (Line 227) }
    # (Line 229) const CheckIntegrityFlag = PVariable();

CheckIntegrityFlag = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 230) function CheckIntegrity(){
@EUDFunc
def CheckIntegrity():
    # (Line 231) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 233) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 234) const BaseEPD = BaseAddrEPD[CP];
        BaseEPD = BaseAddrEPD[CP]
        # (Line 235) const LoadEPD = LoadAddrEPD[CP];
        LoadEPD = LoadAddrEPD[CP]
        # (Line 237) for(var i = 0 ; i < scf.SpaceLength / 4; i++){
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= scf.SpaceLength // 4, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 238) const value1 = dwread_epd(BaseEPD + i);
            value1 = f_dwread_epd(BaseEPD + i)
            # (Line 239) const value2 = dwread_epd(LoadEPD + i);
            value2 = f_dwread_epd(LoadEPD + i)
            # (Line 243) if(MSQCSpecial == 0 && (value1 == 0 && value2 == 0)){
            if EUDIf()(EUDSCAnd()(MSQCSpecial == 0)((EUDSCAnd()(value1 == 0)(value2 == 0)()))()):
                # (Line 244) MSQCSpecial = 3;
                MSQCSpecial << (3)
                # (Line 245) }
                # (Line 247) if(MSQCSpecial == 0 && value1 != value2){
            EUDEndIf()
            if EUDIf()(EUDSCAnd()(MSQCSpecial == 0)(value1 == value2, neg=True)()):
                # (Line 248) MSQCSpecial = 4;
                MSQCSpecial << (4)
                # (Line 249) }
                # (Line 250) }
            EUDEndIf()
            # (Line 251) }
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        # (Line 252) }
    EUDEndIf()
    # (Line 255) function DataLoad();

# (Line 256) var TimeOut;
TimeOut = EUDVariable()
# (Line 258) var LastPing;
LastPing = EUDVariable()
# (Line 259) var DisConnectTimer;
DisConnectTimer = EUDVariable()
# (Line 260) var ConnectingTimer;
ConnectingTimer = EUDVariable()
# (Line 261) var ConnectingPoint;
ConnectingPoint = EUDVariable()
# (Line 262) function PlayerExec(){
@EUDFunc
def PlayerExec():
    # (Line 263) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 264) const CurrentTime = dwread_epd(EPD(0x51CE8C));
    CurrentTime = f_dwread_epd(EPD(0x51CE8C))
    # (Line 265) const FrameTick = (LastTick - CurrentTime);
    FrameTick = (LastTick - CurrentTime)
    # (Line 272) const Ping = wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0);
    Ping = f_wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0)
    # (Line 273) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 274) if (LastPing != Ping){
        if EUDIf()(LastPing == Ping, neg=True):
            # (Line 275) if (ConnectStatus[CP] == 0){
            if EUDIf()(ConnectStatus[CP] == 0):
                # (Line 276) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 277) if (CurrentConnectingTimer > 500){
                if EUDIf()(CurrentConnectingTimer <= 500, neg=True):
                    # (Line 278) if (ConnectingPoint == 0){
                    if EUDIf()(ConnectingPoint == 0):
                        # (Line 279) ConnectingTimer = CurrentTime;
                        ConnectingTimer << (CurrentTime)
                        # (Line 280) ConnectingPoint++;
                        ConnectingPoint.__iadd__(1)
                        # (Line 281) }else{
                    if EUDElse()():
                        # (Line 282) ConnectingTimer = 0;
                        ConnectingTimer << (0)
                        # (Line 283) MSQCSpecial = 1;
                        MSQCSpecial << (1)
                        # (Line 284) }
                        # (Line 285) }
                    EUDEndIf()
                    # (Line 286) }
                EUDEndIf()
                # (Line 288) LastPing = Ping;
            EUDEndIf()
            LastPing << (Ping)
            # (Line 289) DisConnectTimer = CurrentTime;
            DisConnectTimer << (CurrentTime)
            # (Line 290) }else{
        if EUDElse()():
            # (Line 291) if (ConnectStatus[CP] == 0){
            if EUDIf()(ConnectStatus[CP] == 0):
                # (Line 292) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 293) if (CurrentConnectingTimer > 1000){
                if EUDIf()(CurrentConnectingTimer <= 1000, neg=True):
                    # (Line 294) ConnectingTimer = CurrentTime;
                    ConnectingTimer << (CurrentTime)
                    # (Line 295) ConnectingPoint = 0;
                    ConnectingPoint << (0)
                    # (Line 296) }
                    # (Line 297) }
                EUDEndIf()
                # (Line 298) }
            EUDEndIf()
            # (Line 299) }
        EUDEndIf()
        # (Line 304) if (ConnectStatus[CP] == 1){
    EUDEndIf()
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 305) if (Memory(0x57F1B0,Exactly,CP)){
        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
            # (Line 306) const CurrentDisConnectTimer = (DisConnectTimer - CurrentTime);
            CurrentDisConnectTimer = (DisConnectTimer - CurrentTime)
            # (Line 307) if (CurrentDisConnectTimer > 500){
            if EUDIf()(CurrentDisConnectTimer <= 500, neg=True):
                # (Line 308) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 309) LastPing = 0;
                LastPing << (0)
                # (Line 310) MSQCSpecial = 2;
                MSQCSpecial << (2)
                # (Line 311) }
                # (Line 312) }
            EUDEndIf()
            # (Line 316) if(MSQCSpecialBuffer[CP] == 200){
        EUDEndIf()
        if EUDIf()(MSQCSpecialBuffer[CP] == 200):
            # (Line 317) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 318) ConnectStatus[CP] = 0;
            _ARRW(ConnectStatus, CP) << (0)
            # (Line 319) MSQCSpecialBuffer[CP] = 0;
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 320) SCACommand[CP] = 0;
            _ARRW(SCACommand, CP) << (0)
            # (Line 321) SCALastMessage[CP] = 2;
            _ARRW(SCALastMessage, CP) << (2)
            # (Line 322) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 323) PlayWAV("sound\\Bullet\\tscFir00.wav");
                # (Line 324) f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.");
                DoActions(PlayWAV("sound\\Bullet\\tscFir00.wav"))
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.")
                # (Line 325) }
                # (Line 327) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 328) MSQCSpecial = 0;
                MSQCSpecial << (0)
                # (Line 329) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 330) LastPing = 0;
                LastPing << (0)
                # (Line 331) bwrite_epd(orderAddrEPD, 2, 0);
                f_bwrite_epd(orderAddrEPD, 2, 0)
                # (Line 332) bwrite_epd(orderAddrEPD, 3, 0);
                f_bwrite_epd(orderAddrEPD, 3, 0)
                # (Line 333) MSQCCondiction = 0;
                MSQCCondiction << (0)
                # (Line 334) }
                # (Line 335) }
            EUDEndIf()
            # (Line 340) switch(SCACommand[CP]) {
        EUDEndIf()
        EUDSwitch(SCACommand[CP])
        # (Line 341) case 1:
        _t14 = EUDSwitchCase()
        # (Line 342) case 2:
        if _t14(1):
            pass
        _t15 = EUDSwitchCase()
        # (Line 343) case 3:
        if _t15(2):
            pass
        _t16 = EUDSwitchCase()
        # (Line 344) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
        if _t16(3):
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 345) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 347) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 349) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 350) }
                # (Line 355) const LauncherStatus = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            LauncherStatus = f_bread_epd(orderAddrEPD, 3)
            # (Line 356) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 357) if(rn[CP] == 1){
                if EUDIf()(rn[CP] == 1):
                    # (Line 358) f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...");
                    f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...")
                    # (Line 359) }else if(CheckIntegrityFlag[CP] == 0){
                if EUDElseIf()(CheckIntegrityFlag[CP] == 0):
                    # (Line 360) f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP]);
                    f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP])
                    # (Line 361) }else if(CheckIntegrityFlag[CP] == 1){
                if EUDElseIf()(CheckIntegrityFlag[CP] == 1):
                    # (Line 362) f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ");
                    f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ")
                    # (Line 363) }
                    # (Line 364) }
                EUDEndIf()
                # (Line 367) if(CheckIntegrityFlag[CP] == 0){
            EUDEndIf()
            if EUDIf()(CheckIntegrityFlag[CP] == 0):
                # (Line 368) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 369) MSQCCondiction = 1;
                    MSQCCondiction << (1)
                    # (Line 370) }
                    # (Line 373) {
                EUDEndIf()
                # (Line 374) const RecevieValue = ReceiveValue(MSQCBuffer[CP]);
                RecevieValue = ReceiveValue(MSQCBuffer[CP])
                # (Line 376) if(ack[CP] == (rn[CP] % ackMax + 1)){
                if EUDIf()(ack[CP] == (rn[CP] % ackMax + 1)):
                    # (Line 378) const rseq = rn[CP] - 1;
                    rseq = rn[CP] - 1
                    # (Line 379) wwrite_epd(LoadAddrEPD[CP] + rseq / 2, (rseq % 2) * 2, RecevieValue);
                    f_wwrite_epd(LoadAddrEPD[CP] + rseq // 2, (rseq % 2) * 2, RecevieValue)
                    # (Line 380) rn[CP] += 1;
                    _ARRW(rn, CP).__iadd__(1)
                    # (Line 381) }else if(ack[CP] == 0 && RecevieValue == 0xFFFF){
                if EUDElseIf()(EUDSCAnd()(ack[CP] == 0)(RecevieValue == 0xFFFF)()):
                    # (Line 382) MaxBuffer[CP] = rn[CP] - 1;
                    _ARRW(MaxBuffer, CP) << (rn[CP] - 1)
                    # (Line 383) }else{
                if EUDElse()():
                    # (Line 384) const CurrentTimeer = (TimeOut - CurrentTime);
                    CurrentTimeer = (TimeOut - CurrentTime)
                    # (Line 385) if (CurrentTimeer > 500){
                    if EUDIf()(CurrentTimeer <= 500, neg=True):
                        # (Line 386) TimeOut = CurrentTime;
                        TimeOut << (CurrentTime)
                        # (Line 387) index = rn[CP];
                        index << (rn[CP])
                        # (Line 388) }
                        # (Line 389) }
                    EUDEndIf()
                    # (Line 390) }
                EUDEndIf()
                # (Line 394) if(LauncherStatus == 1){
                if EUDIf()(LauncherStatus == 1):
                    # (Line 395) const rseq = index - 1;
                    rseq = index - 1
                    # (Line 396) const CheckZero = dwread_epd(BaseAddrEPD[CP] + rseq / 2);
                    CheckZero = f_dwread_epd(BaseAddrEPD[CP] + rseq // 2)
                    # (Line 398) if (CheckZero == 0){
                    if EUDIf()(CheckZero == 0):
                        # (Line 400) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 401) MSQCValue = DisConnectCode % MapDim + (DisConnectCode / MapDim) * 0x10000;
                            MSQCValue << (DisConnectCode % MapDim + (DisConnectCode // MapDim) * 0x10000)
                            # (Line 402) }
                            # (Line 403) }else{
                        EUDEndIf()
                    if EUDElse()():
                        # (Line 404) SendValue(index);
                        SendValue(index)
                        # (Line 405) if (FrameTick > 70){
                        if EUDIf()(FrameTick <= 70, neg=True):
                            # (Line 406) LastTick = CurrentTime;
                            LastTick << (CurrentTime)
                            # (Line 407) index += 1;
                            index.__iadd__(1)
                            # (Line 408) }
                            # (Line 409) }
                        EUDEndIf()
                        # (Line 410) }
                    EUDEndIf()
                    # (Line 411) }
                EUDEndIf()
                # (Line 416) {if (rn[CP] > MaxBuffer[CP]){
            EUDEndIf()
            if EUDIf()(rn[CP] <= MaxBuffer[CP], neg=True):
                # (Line 417) const rseq = MaxBuffer[CP];
                rseq = MaxBuffer[CP]
                # (Line 418) dwwrite_epd(LoadAddrEPD[CP] + rseq / 2, 0);
                f_dwwrite_epd(LoadAddrEPD[CP] + rseq // 2, 0)
                # (Line 421) switch(CheckIntegrityFlag[CP]){
                EUDSwitch(CheckIntegrityFlag[CP])
                # (Line 422) case 0:
                _t32 = EUDSwitchCase()
                # (Line 423) if (Memory(0x57F1B0,Exactly,CP)){
                if _t32(0):
                    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 424) MSQCCondiction = 0;
                        MSQCCondiction << (0)
                        # (Line 425) }
                        # (Line 426) CheckIntegrity();
                    EUDEndIf()
                    CheckIntegrity()
                    # (Line 427) CheckIntegrityFlag[CP] = 1;
                    _ARRW(CheckIntegrityFlag, CP) << (1)
                    # (Line 428) break;
                    EUDBreak()
                    # (Line 429) case 1:
                _t34 = EUDSwitchCase()
                # (Line 430) CheckIntegrity();
                if _t34(1):
                    CheckIntegrity()
                    # (Line 432) if(MSQCSpecialBuffer[CP] == 300){
                    if EUDIf()(MSQCSpecialBuffer[CP] == 300):
                        # (Line 434) CheckIntegrityFlag[CP] = 2;
                        _ARRW(CheckIntegrityFlag, CP) << (2)
                        # (Line 435) MSQCSpecialBuffer[CP] = 0;
                        _ARRW(MSQCSpecialBuffer, CP) << (0)
                        # (Line 436) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 437) MSQCSpecial = 0;
                            MSQCSpecial << (0)
                            # (Line 438) }
                            # (Line 439) }
                        EUDEndIf()
                        # (Line 440) if(MSQCSpecialBuffer[CP] == 400){
                    EUDEndIf()
                    if EUDIf()(MSQCSpecialBuffer[CP] == 400):
                        # (Line 441) CheckIntegrityFlag[CP] = 0;
                        _ARRW(CheckIntegrityFlag, CP) << (0)
                        # (Line 442) MaxBuffer[CP] = scf.SpaceLength / 2;
                        _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
                        # (Line 443) rn[CP] = 1;
                        _ARRW(rn, CP) << (1)
                        # (Line 444) ack[CP] = 0;
                        _ARRW(ack, CP) << (0)
                        # (Line 445) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 446) MSQCSpecial = 0;
                            MSQCSpecial << (0)
                            # (Line 447) index = 1;
                            index << (1)
                            # (Line 448) }
                            # (Line 449) }
                        EUDEndIf()
                        # (Line 450) break;
                    EUDEndIf()
                    EUDBreak()
                    # (Line 451) case 2:
                _t39 = EUDSwitchCase()
                # (Line 452) if (Memory(0x57F1B0,Exactly,CP)){
                if _t39(2):
                    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 453) bwrite_epd(orderAddrEPD, 2, 0);
                        f_bwrite_epd(orderAddrEPD, 2, 0)
                        # (Line 454) bwrite_epd(orderAddrEPD, 3, 0);
                        f_bwrite_epd(orderAddrEPD, 3, 0)
                        # (Line 455) MSQCValue = 0;
                        MSQCValue << (0)
                        # (Line 456) MSQCCondiction = 0;
                        MSQCCondiction << (0)
                        # (Line 457) }
                        # (Line 458) LoadDataRead(rn[CP] - 1);
                    EUDEndIf()
                    LoadDataRead(rn[CP] - 1)
                    # (Line 459) SCACommand[CP] = 0;
                    _ARRW(SCACommand, CP) << (0)
                    # (Line 461) SCALastMessage[CP] = 4;
                    _ARRW(SCALastMessage, CP) << (4)
                    # (Line 462) if (SCAUseUserMessage == 1){
                    if EUDIf()(SCAUseUserMessage == 1):
                        # (Line 463) PlayWAV("sound\\Misc\\TDrTra01.wav");
                        # (Line 464) f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.");
                        DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                        f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.")
                        # (Line 465) }
                        # (Line 466) break;
                    EUDEndIf()
                    EUDBreak()
                    # (Line 467) }
                # (Line 468) }}
                EUDEndSwitch()
            EUDEndIf()
            # (Line 469) break;
            EUDBreak()
            # (Line 470) case 4:
        _t42 = EUDSwitchCase()
        # (Line 471) if (Memory(0x57F1B0,Exactly,CP)){
        if _t42(4):
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 473) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 476) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 478) }
                # (Line 483) const LauncherStatus2 = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            LauncherStatus2 = f_bread_epd(orderAddrEPD, 3)
            # (Line 484) if(LauncherStatus2 == 1){
            if EUDIf()(LauncherStatus2 == 1):
                # (Line 486) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 487) MSQCValue = 100;
                    MSQCValue << (100)
                    # (Line 488) MSQCCondiction = 1;
                    MSQCCondiction << (1)
                    # (Line 489) }
                    # (Line 490) }
                EUDEndIf()
                # (Line 491) if(MSQCBuffer[CP] == 100){
            EUDEndIf()
            if EUDIf()(MSQCBuffer[CP] == 100):
                # (Line 492) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 493) bwrite_epd(orderAddrEPD, 2, 0);
                    f_bwrite_epd(orderAddrEPD, 2, 0)
                    # (Line 494) bwrite_epd(orderAddrEPD, 3, 0);
                    f_bwrite_epd(orderAddrEPD, 3, 0)
                    # (Line 495) MSQCValue = 0;
                    MSQCValue << (0)
                    # (Line 496) MSQCCondiction = 0;
                    MSQCCondiction << (0)
                    # (Line 497) }
                    # (Line 498) SCACommand[CP] = 0;
                EUDEndIf()
                _ARRW(SCACommand, CP) << (0)
                # (Line 500) SCALastMessage[CP] = 6;
                _ARRW(SCALastMessage, CP) << (6)
                # (Line 501) if (SCAUseUserMessage == 1){
                if EUDIf()(SCAUseUserMessage == 1):
                    # (Line 502) PlayWAV("sound\\Misc\\TDrTra01.wav");
                    # (Line 503) f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.");
                    DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                    f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.")
                    # (Line 504) }
                    # (Line 505) }
                EUDEndIf()
                # (Line 506) break;
            EUDEndIf()
            EUDBreak()
            # (Line 507) }
        # (Line 508) }else{
        EUDEndSwitch()
    if EUDElse()():
        # (Line 509) if(MSQCSpecialBuffer[CP] == 100){
        if EUDIf()(MSQCSpecialBuffer[CP] == 100):
            # (Line 510) ConnectStatus[CP] = 1;
            _ARRW(ConnectStatus, CP) << (1)
            # (Line 511) MSQCSpecialBuffer[CP] = 0;
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 512) SCALastMessage[CP] = 1;
            _ARRW(SCALastMessage, CP) << (1)
            # (Line 513) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 514) PlayWAV("sound\\Misc\\ZRescue.wav");
                # (Line 515) f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.");
                DoActions(PlayWAV("sound\\Misc\\ZRescue.wav"))
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.")
                # (Line 516) }
                # (Line 517) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 518) MSQCSpecial = 0;
                MSQCSpecial << (0)
                # (Line 519) }
                # (Line 520) }
            EUDEndIf()
            # (Line 521) }
        EUDEndIf()
        # (Line 526) }
    EUDEndIf()
    # (Line 528) function Exec(){

@EUDFunc
def Exec():
    # (Line 529) EUDPlayerLoop()();
    EUDPlayerLoop()()
    # (Line 530) PlayerExec();
    PlayerExec()
    # (Line 531) EUDEndPlayerLoop();
    EUDEndPlayerLoop()
    # (Line 532) }
    # (Line 535) function DataLoad(Slot){

@EUDFunc
def DataLoad(Slot):
    # (Line 536) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 538) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 539) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 540) DataSlot[CP] = Slot;
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 541) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 542) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 545) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 547) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 548) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 549) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 550) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 551) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 552) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 553) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 554) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 555) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 556) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 557) index = 1;
                index << (1)
                # (Line 558) }
                # (Line 559) SCACommand[CP] = 1;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (1)
            # (Line 560) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 561) }else{
        if EUDElse()():
            # (Line 562) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 563) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 564) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 565) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 566) }
                # (Line 567) }
            EUDEndIf()
            # (Line 568) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 569) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 570) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 571) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 572) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 573) }
            # (Line 574) }
        EUDEndIf()
        # (Line 575) }
    EUDEndIf()
    # (Line 578) function DataSave(Slot){

@EUDFunc
def DataSave(Slot):
    # (Line 579) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 581) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 582) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 583) DataSlot[CP] = Slot;
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 584) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 586) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 587) SaveDataWrite();
                SaveDataWrite()
                # (Line 588) }
                # (Line 590) MSQCBuffer[CP] = 0;
            EUDEndIf()
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 591) SCALastMessage[CP] = 5;
            _ARRW(SCALastMessage, CP) << (5)
            # (Line 592) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 593) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 594) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 596) SCACommand[CP] = 4;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (4)
            # (Line 597) }else{
        if EUDElse()():
            # (Line 598) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 599) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 600) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 601) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 602) }
                # (Line 603) }
            EUDEndIf()
            # (Line 604) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 605) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 606) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 607) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 608) f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 609) }
            # (Line 610) }
        EUDEndIf()
        # (Line 611) }
    EUDEndIf()
    # (Line 615) function GetDate(){

@EUDFunc
def GetDate():
    # (Line 616) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 617) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 618) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 619) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 620) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 623) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 625) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 626) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 627) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 628) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 629) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 630) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 631) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 632) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 633) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 634) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 635) index = 1;
                index << (1)
                # (Line 636) }
                # (Line 637) SCACommand[CP] = 2;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (2)
            # (Line 638) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 639) }else{
        if EUDElse()():
            # (Line 640) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 641) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 642) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 643) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 644) }
                # (Line 645) }
            EUDEndIf()
            # (Line 646) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 647) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 648) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 649) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 650) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 651) }
            # (Line 652) }
        EUDEndIf()
        # (Line 653) }
    EUDEndIf()
    # (Line 656) function LoadGlobalData(){

@EUDFunc
def LoadGlobalData():
    # (Line 657) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 658) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 659) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 660) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 661) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 664) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 666) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 667) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 668) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 669) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 670) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 671) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 672) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 673) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 674) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 675) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 676) index = 1;
                index << (1)
                # (Line 677) }
                # (Line 678) SCACommand[CP] = 3;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (3)
            # (Line 679) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 680) }else{
        if EUDElse()():
            # (Line 681) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 682) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 683) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 684) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 685) }
                # (Line 686) }
            EUDEndIf()
            # (Line 687) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 688) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 689) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 690) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 691) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 692) }
            # (Line 693) }
        EUDEndIf()
        # (Line 694) }
    EUDEndIf()
