## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import Screen as screen;
import Screen as screen
# (Line 2) import Potal as potal;
import Potal as potal
# (Line 3) import User.Info as user;
from User import Info as user
# (Line 4) import User.Stats as stats;
from User import Stats as stats
# (Line 5) import Variable as v;
import Variable as v
# (Line 6) import Box as box;
import Box as box
# (Line 7) import Inventory as inven;
import Inventory as inven
# (Line 8) import Equip as equip;
import Equip as equip
# (Line 9) import Item.Manager as item;
from Item import Manager as item
# (Line 11) import Monster.Location as mobloc;
from Monster import Location as mobloc
# (Line 12) import Monster.Info as mobinfo;
from Monster import Info as mobinfo
# (Line 13) import NPC.CreateNPC as npc;
from NPC import CreateNPC as npc
# (Line 14) import Field.DrawVillage01 as vil01;
from Field import DrawVillage01 as vil01
# (Line 16) const single = EUDVariable();
single = _CGFW(lambda: [EUDVariable()], 1)[0]
# (Line 17) const useSCA = EUDVariable();
useSCA = _CGFW(lambda: [EUDVariable()], 1)[0]
# (Line 19) function SetNextUnitPTR();
# (Line 20) function SetNextUnitEPD();
# (Line 21) function SetAlliance();
# (Line 22) function ButtonRefresh();
# (Line 23) function SetPColor(pnum, color);
# (Line 24) function Heal();
# (Line 26) function Init() {
@EUDTracedFunc
def Init():
    # (Line 27) setcurpl(6);
    EUDTraceLog(27)
    f_setcurpl(6)
    # (Line 28) SetAllianceStatus(Force1, Ally);
    # (Line 29) potal.PotalInit();
    EUDTraceLog(28)
    DoActions(SetAllianceStatus(Force1, Ally))
    EUDTraceLog(29)
    potal.PotalInit()
    # (Line 31) item.Init();
    EUDTraceLog(31)
    item.Init()
    # (Line 34) mobinfo.SetInfo();
    EUDTraceLog(34)
    mobinfo.SetInfo()
    # (Line 35) mobloc.MobSpawnLocationCheck();
    EUDTraceLog(35)
    mobloc.MobSpawnLocationCheck()
    # (Line 36) npc.CreateNPC();
    EUDTraceLog(36)
    npc.CreateNPC()
    # (Line 37) SetPColor(7, 0);
    EUDTraceLog(37)
    SetPColor(7, 0)
    # (Line 38) SetPColor(8, 196);
    EUDTraceLog(38)
    SetPColor(8, 196)
    # (Line 39) if(Memory(0x57F0B4, Exactly, 0)) SetVariables(single, 1);
    _t1 = EUDIf()
    EUDTraceLog(39)
    if _t1(Memory(0x57F0B4, Exactly, 0)):
        EUDTraceLog(39)
        SetVariables(single, 1)
        # (Line 40) else SetVariables(single, 0);
    if EUDElse()():
        EUDTraceLog(40)
        SetVariables(single, 0)
        # (Line 43) SetVariables(useSCA, false);
    EUDEndIf()
    EUDTraceLog(43)
    SetVariables(useSCA, False)
    # (Line 45) foreach (cp : EUDLoopPlayer()) {
    for cp in EUDLoopPlayer():
        # (Line 46) setcurpl(cp);
        EUDTraceLog(46)
        f_setcurpl(cp)
        # (Line 47) SetAllianceStatus(P7, Ally);
        # (Line 48) inven.ResetInven();
        EUDTraceLog(47)
        DoActions(SetAllianceStatus(P7, Ally))
        EUDTraceLog(48)
        inven.ResetInven()
        # (Line 49) equip.ResetEquip();
        EUDTraceLog(49)
        equip.ResetEquip()
        # (Line 50) screen.light[cp] = 31;
        EUDTraceLog(50)
        _ARRW(screen.light, cp) << (31)
        # (Line 51) }
        # (Line 52) }

    # (Line 54) function Stop() {

@EUDTracedFunc
def Stop():
    # (Line 55) const cp = getcurpl();
    EUDTraceLog(55)
    cp = f_getcurpl()
    # (Line 56) MoveUnit(1, v.unitNum[cp], cp, "Anywhere", "Black");
    # (Line 57) }
    EUDTraceLog(56)
    DoActions(MoveUnit(1, v.unitNum[cp], cp, "Anywhere", "Black"))
    # (Line 59) function SetNextUnitPTR() {

@EUDTracedFunc
def SetNextUnitPTR():
    # (Line 60) return dwread_epd(EPD(0x628438));
    EUDTraceLog(60)
    EUDReturn(f_dwread_epd(EPD(0x628438)))
    # (Line 61) }
    # (Line 63) function SetNextUnitEPD() {

@EUDTracedFunc
def SetNextUnitEPD():
    # (Line 64) return epdread_epd(EPD(0x628438));
    EUDTraceLog(64)
    EUDReturn(f_epdread_epd(EPD(0x628438)))
    # (Line 65) }
    # (Line 67) function GetDeath() {

@EUDTracedFunc
def GetDeath():
    # (Line 68) const cp = getcurpl();
    EUDTraceLog(68)
    cp = f_getcurpl()
    # (Line 69) v.key[cp] = dwread_epd(cp + 2148); // 179 Cave
    EUDTraceLog(69)
    _ARRW(v.key, cp) << (f_dwread_epd(cp + 2148))
    # (Line 70) v.numberKey[cp] = dwread_epd(cp + 2160); // 180 Cave-in
    EUDTraceLog(70)
    _ARRW(v.numberKey, cp) << (f_dwread_epd(cp + 2160))
    # (Line 71) v.mouse[cp] = dwread_epd(cp + 84); // 7 SCV
    EUDTraceLog(71)
    _ARRW(v.mouse, cp) << (f_dwread_epd(cp + 84))
    # (Line 72) user.deathZergling[cp] = dwread_epd(cp + 444); // 37 저글링
    EUDTraceLog(72)
    _ARRW(user.deathZergling, cp) << (f_dwread_epd(cp + 444))
    # (Line 73) user.deathCavein[cp] = dwread_epd(cp + 2160); // 180 히드라
    EUDTraceLog(73)
    _ARRW(user.deathCavein, cp) << (f_dwread_epd(cp + 2160))
    # (Line 74) v.chat[cp] = dwread_epd(cp + 492); // 41 드론
    EUDTraceLog(74)
    _ARRW(v.chat, cp) << (f_dwread_epd(cp + 492))
    # (Line 75) }
    # (Line 77) function SetLocation(locationNum: TrgLocation, x, y, size) {

@EUDTracedTypedFunc([TrgLocation, None, None, None])
def SetLocation(locationNum, x, y, size):
    # (Line 78) const loc = EPD(0x58DC4C) + locationNum * 5;
    EUDTraceLog(78)
    loc = EPD(0x58DC4C) + locationNum * 5
    # (Line 79) SetMemoryEPD(loc + 0, SetTo, x - size);
    # (Line 80) SetMemoryEPD(loc + 1, SetTo, y - size);
    EUDTraceLog(79)
    DoActions(SetMemoryEPD(loc + 0, SetTo, x - size))
    # (Line 81) SetMemoryEPD(loc + 2, SetTo, x + size);
    EUDTraceLog(80)
    DoActions(SetMemoryEPD(loc + 1, SetTo, y - size))
    # (Line 82) SetMemoryEPD(loc + 3, SetTo, y + size);
    EUDTraceLog(81)
    DoActions(SetMemoryEPD(loc + 2, SetTo, x + size))
    # (Line 83) }
    EUDTraceLog(82)
    DoActions(SetMemoryEPD(loc + 3, SetTo, y + size))
    # (Line 85) function PlayerLoc() {

@EUDTracedFunc
def PlayerLoc():
    # (Line 86) const cp = getcurpl();
    EUDTraceLog(86)
    cp = f_getcurpl()
    # (Line 87) if(user.isAlive[cp] == true) {
    _t1 = EUDIf()
    EUDTraceLog(87)
    if _t1(user.isAlive[cp] == True):
        # (Line 88) MoveLocation(v.locNum[cp], v.unitNum[cp], cp, "Anywhere");
        # (Line 89) }
        EUDTraceLog(88)
        DoActions(MoveLocation(v.locNum[cp], v.unitNum[cp], cp, "Anywhere"))
        # (Line 90) }
    EUDEndIf()
    # (Line 92) function TextClear() {

@EUDTracedFunc
def TextClear():
    # (Line 93) v.s.print("\n\n\n\n\n\n\n\n\n\n");
    EUDTraceLog(93)
    v.s.print("\n\n\n\n\n\n\n\n\n\n")
    # (Line 94) }
    # (Line 96) function EPDBring(Location: TrgLocation, UnitEPD) {

@EUDTracedTypedFunc([TrgLocation, None])
def EPDBring(Location, UnitEPD):
    # (Line 97) const posUnitX, posUnitY = dwbreak(dwread_epd(UnitEPD + 0x28 / 4))[[0,1]];
    EUDTraceLog(97)
    posUnitX, posUnitY = List2Assignable([_SRET(f_dwbreak(f_dwread_epd(UnitEPD + 0x28 // 4)), [0, 1])])
    # (Line 98) const LocEPD = Location * 5 + EPD(0x58DC4C);
    EUDTraceLog(98)
    LocEPD = Location * 5 + EPD(0x58DC4C)
    # (Line 99) if(
    _t1 = EUDIf()
    # (Line 100) MemoryEPD(LocEPD, AtMost, posUnitX) &&
    # (Line 101) MemoryEPD(LocEPD + 2, AtLeast, posUnitX) &&
    # (Line 102) MemoryEPD(LocEPD + 1, AtMost, posUnitY) &&
    # (Line 103) MemoryEPD(LocEPD + 3, AtLeast, posUnitY)
    # (Line 104) ){
    EUDTraceLog(103)
    if _t1(EUDSCAnd()(MemoryEPD(LocEPD, AtMost, posUnitX))(MemoryEPD(LocEPD + 2, AtLeast, posUnitX))(MemoryEPD(LocEPD + 1, AtMost, posUnitY))(MemoryEPD(LocEPD + 3, AtLeast, posUnitY))()):
        # (Line 105) return True;
        EUDTraceLog(105)
        EUDReturn(True)
        # (Line 106) }
        # (Line 107) return False;
    EUDEndIf()
    EUDTraceLog(107)
    EUDReturn(False)
    # (Line 108) }
    # (Line 110) function StructMemoryXEPD(unitEPD ,StructOffset ,value ,comparison: TrgComparison) {

@EUDTracedTypedFunc([None, None, None, TrgComparison])
def StructMemoryXEPD(unitEPD, StructOffset, value, comparison):
    # (Line 111) var Mask;
    Mask = EUDVariable()
    # (Line 112) switch(StructOffset % 4) {
    EUDTraceLog(112)
    EUDSwitch(StructOffset % 4)
    # (Line 113) case 0:
    _t1 = EUDSwitchCase()
    # (Line 114) if(MemoryEPD(unitEPD + StructOffset / 4, comparison, value))
    EUDTraceLog(113)
    if _t1(0):
        _t2 = EUDIf()
        EUDTraceLog(114)
        if _t2(MemoryEPD(unitEPD + StructOffset // 4, comparison, value)):
            # (Line 115) return True;
            EUDTraceLog(115)
            EUDReturn(True)
            # (Line 116) else return False;
        if EUDElse()():
            EUDTraceLog(116)
            EUDReturn(False)
            # (Line 117) break;
        EUDEndIf()
        EUDTraceLog(117)
        EUDBreak()
        # (Line 118) case 1:
    _t3 = EUDSwitchCase()
    # (Line 119) Mask = 0xFF00;
    EUDTraceLog(118)
    if _t3(1):
        EUDTraceLog(119)
        Mask << (0xFF00)
        # (Line 120) value = value*256;
        EUDTraceLog(120)
        value << (value * 256)
        # (Line 121) break;
        EUDTraceLog(121)
        EUDBreak()
        # (Line 122) case 2:
    _t4 = EUDSwitchCase()
    # (Line 123) Mask = 0xFF0000;
    EUDTraceLog(122)
    if _t4(2):
        EUDTraceLog(123)
        Mask << (0xFF0000)
        # (Line 124) value = value*65536;
        EUDTraceLog(124)
        value << (value * 65536)
        # (Line 125) break;
        EUDTraceLog(125)
        EUDBreak()
        # (Line 126) case 3:
    _t5 = EUDSwitchCase()
    # (Line 127) Mask = 0xFF000000;
    EUDTraceLog(126)
    if _t5(3):
        EUDTraceLog(127)
        Mask << (0xFF000000)
        # (Line 128) value = value*16777216;
        EUDTraceLog(128)
        value << (value * 16777216)
        # (Line 129) break;
        EUDTraceLog(129)
        EUDBreak()
        # (Line 130) }
    # (Line 131) if(MemoryXEPD(unitEPD + StructOffset / 4, comparison, value, Mask)) return true;
    EUDEndSwitch()
    _t6 = EUDIf()
    EUDTraceLog(131)
    if _t6(MemoryXEPD(unitEPD + StructOffset // 4, comparison, value, Mask)):
        EUDTraceLog(131)
        EUDReturn(True)
        # (Line 132) else return false;
    if EUDElse()():
        EUDTraceLog(132)
        EUDReturn(False)
        # (Line 133) }
    EUDEndIf()
    # (Line 135) function StructSetMemoryXEPD(unitEPD ,StructOffset ,value ,modifier: TrgModifier) {

@EUDTracedTypedFunc([None, None, None, TrgModifier])
def StructSetMemoryXEPD(unitEPD, StructOffset, value, modifier):
    # (Line 136) var Mask;
    Mask = EUDVariable()
    # (Line 137) switch(StructOffset % 4) {
    EUDTraceLog(137)
    EUDSwitch(StructOffset % 4)
    # (Line 138) case 0:
    _t1 = EUDSwitchCase()
    # (Line 139) SetMemoryEPD(unitEPD + StructOffset / 4, modifier, value);
    EUDTraceLog(138)
    if _t1(0):
        # (Line 140) return;
        EUDTraceLog(139)
        DoActions(SetMemoryEPD(unitEPD + StructOffset // 4, modifier, value))
        EUDTraceLog(140)
        EUDReturn()
        # (Line 141) break;
        EUDTraceLog(141)
        EUDBreak()
        # (Line 142) case 1:
    _t2 = EUDSwitchCase()
    # (Line 143) Mask = 0xFF00;
    EUDTraceLog(142)
    if _t2(1):
        EUDTraceLog(143)
        Mask << (0xFF00)
        # (Line 144) value = value*256;
        EUDTraceLog(144)
        value << (value * 256)
        # (Line 145) break;
        EUDTraceLog(145)
        EUDBreak()
        # (Line 146) case 2:
    _t3 = EUDSwitchCase()
    # (Line 147) Mask = 0xFF0000;
    EUDTraceLog(146)
    if _t3(2):
        EUDTraceLog(147)
        Mask << (0xFF0000)
        # (Line 148) value = value*65536;
        EUDTraceLog(148)
        value << (value * 65536)
        # (Line 149) break;
        EUDTraceLog(149)
        EUDBreak()
        # (Line 150) case 3:
    _t4 = EUDSwitchCase()
    # (Line 151) Mask = 0xFF000000;
    EUDTraceLog(150)
    if _t4(3):
        EUDTraceLog(151)
        Mask << (0xFF000000)
        # (Line 152) value = value*16777216;
        EUDTraceLog(152)
        value << (value * 16777216)
        # (Line 153) break;
        EUDTraceLog(153)
        EUDBreak()
        # (Line 154) }
    # (Line 155) SetMemoryXEPD(unitEPD + StructOffset / 4, modifier, value, Mask);
    EUDEndSwitch()
    # (Line 156) }
    EUDTraceLog(155)
    DoActions(SetMemoryXEPD(unitEPD + StructOffset // 4, modifier, value, Mask))
    # (Line 158) function CloseWindow() {

@EUDTracedFunc
def CloseWindow():
    # (Line 159) inven.Close();
    EUDTraceLog(159)
    inven.Close()
    # (Line 160) equip.Close();
    EUDTraceLog(160)
    equip.Close()
    # (Line 161) }
    # (Line 163) function clickedLine(line) {

@EUDTracedFunc
def f_clickedLine(line):
    # (Line 164) const cp = getcurpl();
    EUDTraceLog(164)
    cp = f_getcurpl()
    # (Line 165) if(line == 0) {
    _t1 = EUDIf()
    EUDTraceLog(165)
    if _t1(line == 0):
        # (Line 166) if(v.mouseY[cp] >= 112 && v.mouseY[cp] <= 126) return true;
        _t2 = EUDIf()
        EUDTraceLog(166)
        if _t2(EUDSCAnd()(v.mouseY[cp] >= 112)(v.mouseY[cp] <= 126)()):
            EUDTraceLog(166)
            EUDReturn(True)
            # (Line 167) else return false;
        if EUDElse()():
            EUDTraceLog(167)
            EUDReturn(False)
            # (Line 168) }
        EUDEndIf()
        # (Line 169) else if(line == 1) {
    _t3 = EUDElseIf()
    EUDTraceLog(169)
    if _t3(line == 1):
        # (Line 170) if(v.mouseY[cp] >= 128 && v.mouseY[cp] <= 142) return true;
        _t4 = EUDIf()
        EUDTraceLog(170)
        if _t4(EUDSCAnd()(v.mouseY[cp] >= 128)(v.mouseY[cp] <= 142)()):
            EUDTraceLog(170)
            EUDReturn(True)
            # (Line 171) else return false;
        if EUDElse()():
            EUDTraceLog(171)
            EUDReturn(False)
            # (Line 172) }
        EUDEndIf()
        # (Line 173) else if(line == 2) {
    _t5 = EUDElseIf()
    EUDTraceLog(173)
    if _t5(line == 2):
        # (Line 174) if(v.mouseY[cp] >= 144 && v.mouseY[cp] <= 158) return true;
        _t6 = EUDIf()
        EUDTraceLog(174)
        if _t6(EUDSCAnd()(v.mouseY[cp] >= 144)(v.mouseY[cp] <= 158)()):
            EUDTraceLog(174)
            EUDReturn(True)
            # (Line 175) else return false;
        if EUDElse()():
            EUDTraceLog(175)
            EUDReturn(False)
            # (Line 176) }
        EUDEndIf()
        # (Line 177) else if(line == 3) {
    _t7 = EUDElseIf()
    EUDTraceLog(177)
    if _t7(line == 3):
        # (Line 178) if(v.mouseY[cp] >= 160 && v.mouseY[cp] <= 174) return true;
        _t8 = EUDIf()
        EUDTraceLog(178)
        if _t8(EUDSCAnd()(v.mouseY[cp] >= 160)(v.mouseY[cp] <= 174)()):
            EUDTraceLog(178)
            EUDReturn(True)
            # (Line 179) else return false;
        if EUDElse()():
            EUDTraceLog(179)
            EUDReturn(False)
            # (Line 180) }
        EUDEndIf()
        # (Line 181) else if(line == 4) {
    _t9 = EUDElseIf()
    EUDTraceLog(181)
    if _t9(line == 4):
        # (Line 182) if(v.mouseY[cp] >= 176 && v.mouseY[cp] <= 190) return true;
        _t10 = EUDIf()
        EUDTraceLog(182)
        if _t10(EUDSCAnd()(v.mouseY[cp] >= 176)(v.mouseY[cp] <= 190)()):
            EUDTraceLog(182)
            EUDReturn(True)
            # (Line 183) else return false;
        if EUDElse()():
            EUDTraceLog(183)
            EUDReturn(False)
            # (Line 184) }
        EUDEndIf()
        # (Line 185) else if(line == 5) {
    _t11 = EUDElseIf()
    EUDTraceLog(185)
    if _t11(line == 5):
        # (Line 186) if(v.mouseY[cp] >= 192 && v.mouseY[cp] <= 206) return true;
        _t12 = EUDIf()
        EUDTraceLog(186)
        if _t12(EUDSCAnd()(v.mouseY[cp] >= 192)(v.mouseY[cp] <= 206)()):
            EUDTraceLog(186)
            EUDReturn(True)
            # (Line 187) else return false;
        if EUDElse()():
            EUDTraceLog(187)
            EUDReturn(False)
            # (Line 188) }
        EUDEndIf()
        # (Line 189) else if(line == 6) {
    _t13 = EUDElseIf()
    EUDTraceLog(189)
    if _t13(line == 6):
        # (Line 190) if(v.mouseY[cp] >= 208 && v.mouseY[cp] <= 222) return true;
        _t14 = EUDIf()
        EUDTraceLog(190)
        if _t14(EUDSCAnd()(v.mouseY[cp] >= 208)(v.mouseY[cp] <= 222)()):
            EUDTraceLog(190)
            EUDReturn(True)
            # (Line 191) else return false;
        if EUDElse()():
            EUDTraceLog(191)
            EUDReturn(False)
            # (Line 192) }
        EUDEndIf()
        # (Line 193) else if(line == 7) {
    _t15 = EUDElseIf()
    EUDTraceLog(193)
    if _t15(line == 7):
        # (Line 194) if(v.mouseY[cp] >= 224 && v.mouseY[cp] <= 238) return true;
        _t16 = EUDIf()
        EUDTraceLog(194)
        if _t16(EUDSCAnd()(v.mouseY[cp] >= 224)(v.mouseY[cp] <= 238)()):
            EUDTraceLog(194)
            EUDReturn(True)
            # (Line 195) else return false;
        if EUDElse()():
            EUDTraceLog(195)
            EUDReturn(False)
            # (Line 196) }
        EUDEndIf()
        # (Line 197) else if(line == 8) {
    _t17 = EUDElseIf()
    EUDTraceLog(197)
    if _t17(line == 8):
        # (Line 198) if(v.mouseY[cp] >= 240 && v.mouseY[cp] <= 254) return true;
        _t18 = EUDIf()
        EUDTraceLog(198)
        if _t18(EUDSCAnd()(v.mouseY[cp] >= 240)(v.mouseY[cp] <= 254)()):
            EUDTraceLog(198)
            EUDReturn(True)
            # (Line 199) else return false;
        if EUDElse()():
            EUDTraceLog(199)
            EUDReturn(False)
            # (Line 200) }
        EUDEndIf()
        # (Line 201) else if(line == 9) {
    _t19 = EUDElseIf()
    EUDTraceLog(201)
    if _t19(line == 9):
        # (Line 202) if(v.mouseY[cp] >= 256 && v.mouseY[cp] <= 270) return true;
        _t20 = EUDIf()
        EUDTraceLog(202)
        if _t20(EUDSCAnd()(v.mouseY[cp] >= 256)(v.mouseY[cp] <= 270)()):
            EUDTraceLog(202)
            EUDReturn(True)
            # (Line 203) else return false;
        if EUDElse()():
            EUDTraceLog(203)
            EUDReturn(False)
            # (Line 204) }
        EUDEndIf()
        # (Line 205) }
    EUDEndIf()
    # (Line 207) function UDPBan(){

@EUDTracedFunc
def UDPBan():
    # (Line 208) const a = 0x6D0F48; //방이름
    EUDTraceLog(208)
    a = 0x6D0F48
    # (Line 209) const b = 0x6D0F78; //방장닉
    EUDTraceLog(209)
    b = 0x6D0F78
    # (Line 210) if(strcmp(a, b) == 0) {
    _t1 = EUDIf()
    EUDTraceLog(210)
    if _t1(f_strcmp(a, b) == 0):
        # (Line 211) for(var i=0; i<4; i++) {
        EUDTraceLog(211)
        i = EUDVariable()
        i << (0)
        _t2 = EUDWhile()
        EUDTraceLog(211)
        if _t2(i >= 4, neg=True):
            def _t3():
                EUDTraceLog(211)
                i.__iadd__(1)
            # (Line 212) setcurpl(i);
            EUDTraceLog(212)
            f_setcurpl(i)
            # (Line 213) v.s.print("\x13\x1EUDP에서 플레이는 금지하고 있습니다."); Defeat();
            EUDTraceLog(213)
            v.s.print("\x13\x1EUDP에서 플레이는 금지하고 있습니다.")
            # (Line 214) }
            EUDTraceLog(213)
            DoActions(Defeat())
            # (Line 215) }
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        # (Line 216) }
    EUDEndIf()
    # (Line 218) function SpeedBan(){

@EUDTracedFunc
def SpeedBan():
    # (Line 219) const a = dwread_epd_safe(EPD(0x51CE84));
    EUDTraceLog(219)
    a = f_dwread_epd_safe(EPD(0x51CE84))
    # (Line 220) const b = dwread_epd_safe(EPD(0x51CE88));
    EUDTraceLog(220)
    b = f_dwread_epd_safe(EPD(0x51CE88))
    # (Line 221) if(a == 1000){if(b == 1000) return;}		//턴레이트24
    _t1 = EUDIf()
    EUDTraceLog(221)
    if _t1(a == 1000):
        _t2 = EUDIf()
        EUDTraceLog(221)
        if _t2(b == 1000):
            EUDTraceLog(221)
            EUDReturn()
        EUDEndIf()
        # (Line 222) else if(a == 1042){if(b == 1190) return;}	//턴레이트20
    _t3 = EUDElseIf()
    EUDTraceLog(222)
    if _t3(a == 1042):
        _t4 = EUDIf()
        EUDTraceLog(222)
        if _t4(b == 1190):
            EUDTraceLog(222)
            EUDReturn()
        EUDEndIf()
        # (Line 223) else if(a == 1302){if(b == 1488) return;}	//턴레이트16
    _t5 = EUDElseIf()
    EUDTraceLog(223)
    if _t5(a == 1302):
        _t6 = EUDIf()
        EUDTraceLog(223)
        if _t6(b == 1488):
            EUDTraceLog(223)
            EUDReturn()
        EUDEndIf()
        # (Line 224) else if(a == 1488){if(b == 1701) return;}	//턴레이트14
    _t7 = EUDElseIf()
    EUDTraceLog(224)
    if _t7(a == 1488):
        _t8 = EUDIf()
        EUDTraceLog(224)
        if _t8(b == 1701):
            EUDTraceLog(224)
            EUDReturn()
        EUDEndIf()
        # (Line 225) else if(a == 1736){if(b == 1984) return;}	//턴레이트12
    _t9 = EUDElseIf()
    EUDTraceLog(225)
    if _t9(a == 1736):
        _t10 = EUDIf()
        EUDTraceLog(225)
        if _t10(b == 1984):
            EUDTraceLog(225)
            EUDReturn()
        EUDEndIf()
        # (Line 226) else if(a == 2083){if(b == 2381) return;}	//턴레이트10
    _t11 = EUDElseIf()
    EUDTraceLog(226)
    if _t11(a == 2083):
        _t12 = EUDIf()
        EUDTraceLog(226)
        if _t12(b == 2381):
            EUDTraceLog(226)
            EUDReturn()
        EUDEndIf()
        # (Line 227) else if(a == 2604){if(b == 2976) return;}	//턴레이트8
    _t13 = EUDElseIf()
    EUDTraceLog(227)
    if _t13(a == 2604):
        _t14 = EUDIf()
        EUDTraceLog(227)
        if _t14(b == 2976):
            EUDTraceLog(227)
            EUDReturn()
        EUDEndIf()
        # (Line 228) else{
    if EUDElse()():
        # (Line 229) foreach(cp : EUDLoopPlayer('Human', None, None)) {
        for cp in EUDLoopPlayer('Human', None, None):
            # (Line 230) setcurpl(cp); v.s.print("\x13\x1E배속 플레이는 금지하고 있습니다.");
            EUDTraceLog(230)
            f_setcurpl(cp)
            EUDTraceLog(230)
            v.s.print("\x13\x1E배속 플레이는 금지하고 있습니다.")
            # (Line 231) }
            # (Line 232) dwread(0);

        EUDTraceLog(232)
        f_dwread(0)
        # (Line 233) }
        # (Line 234) }
    EUDEndIf()
    # (Line 236) function GetMousePos() {

@EUDTracedFunc
def GetMousePos():
    # (Line 237) const cp = getcurpl();
    EUDTraceLog(237)
    cp = f_getcurpl()
    # (Line 238) if(v.mouse[cp] == 1) {
    _t1 = EUDIf()
    EUDTraceLog(238)
    if _t1(v.mouse[cp] == 1):
        # (Line 239) v.mouseX[cp] = dwread_epd(cp + 504);
        EUDTraceLog(239)
        _ARRW(v.mouseX, cp) << (f_dwread_epd(cp + 504))
        # (Line 240) v.mouseY[cp] = dwread_epd(cp + 684);
        EUDTraceLog(240)
        _ARRW(v.mouseY, cp) << (f_dwread_epd(cp + 684))
        # (Line 241) }
        # (Line 242) v._mouseX[cp] = dwread_epd(EPD(0x6CDDC4));
    EUDEndIf()
    EUDTraceLog(242)
    _ARRW(v._mouseX, cp) << (f_dwread_epd(EPD(0x6CDDC4)))
    # (Line 243) v._mouseY[cp] = dwread_epd(EPD(0x6CDDC8));
    EUDTraceLog(243)
    _ARRW(v._mouseY, cp) << (f_dwread_epd(EPD(0x6CDDC8)))
    # (Line 244) if(v._mouseX[cp] != v._prevMouseX[cp] || v._mouseY[cp] != v._prevMouseY[cp]) {
    _t2 = EUDIf()
    EUDTraceLog(244)
    if _t2(EUDSCOr()(v._mouseX[cp] == v._prevMouseX[cp], neg=True)(v._mouseY[cp] == v._prevMouseY[cp], neg=True)()):
        # (Line 245) v.isMouseMoved[cp] = 1;
        EUDTraceLog(245)
        _ARRW(v.isMouseMoved, cp) << (1)
        # (Line 247) v._prevMouseX[cp] = v._mouseX[cp];
        EUDTraceLog(247)
        _ARRW(v._prevMouseX, cp) << (v._mouseX[cp])
        # (Line 248) v._prevMouseY[cp] = v._mouseY[cp];
        EUDTraceLog(248)
        _ARRW(v._prevMouseY, cp) << (v._mouseY[cp])
        # (Line 249) }
        # (Line 250) }
    EUDEndIf()
    # (Line 252) function SetName() {

@EUDTracedFunc
def SetName():
    # (Line 253) const cp = getcurpl();
    EUDTraceLog(253)
    cp = f_getcurpl()
    # (Line 254) strcpy(v.name[cp], 0x57EEEB + 36 * cp);
    EUDTraceLog(254)
    f_strcpy(v.name[cp], 0x57EEEB + 36 * cp)
    # (Line 255) settbl2(v.unitNum[cp] + 1, 0, "\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D");
    EUDTraceLog(255)
    f_settbl2(v.unitNum[cp] + 1, 0, "\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D")
    # (Line 256) settbl2(v.unitNum[cp] + 1, 0, "\x17:: \x04", ptr2s(v.name[cp]), " \x17::");
    EUDTraceLog(256)
    f_settbl2(v.unitNum[cp] + 1, 0, "\x17:: \x04", ptr2s(v.name[cp]), " \x17::")
    # (Line 257) }
    # (Line 259) function ExpCheck() {

@EUDTracedFunc
def ExpCheck():
    # (Line 260) const cp = getcurpl();
    EUDTraceLog(260)
    cp = f_getcurpl()
    # (Line 261) if(user.prevExp[cp] != user.exp[cp]) {
    _t1 = EUDIf()
    EUDTraceLog(261)
    if _t1(user.prevExp[cp] == user.exp[cp], neg=True):
        # (Line 262) stats.RefreshExp();
        EUDTraceLog(262)
        stats.RefreshExp()
        # (Line 263) user.prevExp[cp] = user.exp[cp];
        EUDTraceLog(263)
        _ARRW(user.prevExp, cp) << (user.exp[cp])
        # (Line 264) bwrite_epd(user.character[cp] + 0x08F / 4,  0x08F % 4, user.level[cp]);
        EUDTraceLog(264)
        f_bwrite_epd(user.character[cp] + 0x08F // 4, 0x08F % 4, user.level[cp])
        # (Line 266) if(user.level[cp] > 0 && user.level[cp] < 100) {
        _t2 = EUDIf()
        EUDTraceLog(266)
        if _t2(EUDSCAnd()(user.level[cp] <= 0, neg=True)(user.level[cp] >= 100, neg=True)()):
            # (Line 267) if(user.exp[cp] >= v.maxExp[user.level[cp]]) {
            _t3 = EUDIf()
            EUDTraceLog(267)
            if _t3(user.exp[cp] >= v.maxExp[user.level[cp]]):
                # (Line 268) user.exp[cp] -= v.maxExp[user.level[cp]];
                EUDTraceLog(268)
                _ARRW(user.exp, cp).__isub__(v.maxExp[user.level[cp]])
                # (Line 269) user.level[cp] += 1;
                EUDTraceLog(269)
                _ARRW(user.level, cp).__iadd__(1)
                # (Line 270) SetMemoryXEPD(user.character[cp] + 0x08F / 4, SetTo, user.level[cp] << 24, 0xFF000000);
                # (Line 271) stats.SetDamage();
                EUDTraceLog(270)
                DoActions(SetMemoryXEPD(user.character[cp] + 0x08F // 4, SetTo, _LSH(user.level[cp],24), 0xFF000000))
                EUDTraceLog(271)
                stats.SetDamage()
                # (Line 272) stats.SetHP();
                EUDTraceLog(272)
                stats.SetHP()
                # (Line 273) Heal();
                EUDTraceLog(273)
                Heal()
                # (Line 274) }
                # (Line 275) }
            EUDEndIf()
            # (Line 276) ButtonRefresh();
        EUDEndIf()
        EUDTraceLog(276)
        ButtonRefresh()
        # (Line 277) }
        # (Line 278) }
    EUDEndIf()
    # (Line 280) function Heal() {

@EUDTracedFunc
def Heal():
    # (Line 281) const cp = getcurpl();
    EUDTraceLog(281)
    cp = f_getcurpl()
    # (Line 282) ModifyUnitHitPoints(1, v.unitNum[cp], cp, "Anywhere", 100);
    # (Line 283) }
    EUDTraceLog(282)
    DoActions(ModifyUnitHitPoints(1, v.unitNum[cp], cp, "Anywhere", 100))
    # (Line 285) function ButtonRefresh() {

@EUDTracedFunc
def ButtonRefresh():
    # (Line 286) const btntemp1 = wread_epd(EPD(0x6615AA), 2);
    EUDTraceLog(286)
    btntemp1 = f_wread_epd(EPD(0x6615AA), 2)
    # (Line 287) SetMemoryX(0x6615AA, SetTo, 0x20000, 0xFFFF0000);
    # (Line 288) const btntemp2, btntemp3 = cunitepdread_epd(EPD(0x628438));
    EUDTraceLog(287)
    DoActions(SetMemoryX(0x6615AA, SetTo, 0x20000, 0xFFFF0000))
    EUDTraceLog(288)
    btntemp2, btntemp3 = List2Assignable([f_cunitepdread_epd(EPD(0x628438))])
    # (Line 289) CreateUnit(1, 73, 64, 7);
    # (Line 290) if(!Memory(0x628438, Exactly, btntemp2)) {
    EUDTraceLog(289)
    DoActions(CreateUnit(1, 73, 64, 7))
    _t1 = EUDIf()
    EUDTraceLog(290)
    if _t1(Memory(0x628438, Exactly, btntemp2), neg=True):
        # (Line 291) wwrite_epd(btntemp3 + 0x110/4, 0, 1);
        EUDTraceLog(291)
        f_wwrite_epd(btntemp3 + 0x110 // 4, 0, 1)
        # (Line 292) wwrite_epd(EPD(0x6615AA), 2, btntemp1);
        EUDTraceLog(292)
        f_wwrite_epd(EPD(0x6615AA), 2, btntemp1)
        # (Line 293) };
    EUDEndIf()
    # (Line 294) }
    # (Line 296) function SetPColor(pnum, color) {

@EUDTracedFunc
def SetPColor(pnum, color):
    # (Line 297) const pcolor_dst = 0x581D76 + 8 * pnum;
    EUDTraceLog(297)
    pcolor_dst = 0x581D76 + 8 * pnum
    # (Line 298) const mcolor_dst = 0x581DD6 + pnum;
    EUDTraceLog(298)
    mcolor_dst = 0x581DD6 + pnum
    # (Line 299) bwrite(pcolor_dst, color);
    EUDTraceLog(299)
    f_bwrite(pcolor_dst, color)
    # (Line 300) bwrite(mcolor_dst, color);
    EUDTraceLog(300)
    f_bwrite(mcolor_dst, color)
    # (Line 301) }
    # (Line 303) function SetUnitColorEPD(UnitEPD, Color) {

@EUDTracedFunc
def SetUnitColorEPD(UnitEPD, Color):
    # (Line 304) var spriteEPD = epdread_epd(UnitEPD + 0x00C / 4);
    EUDTraceLog(304)
    spriteEPD = EUDVariable()
    spriteEPD << (f_epdread_epd(UnitEPD + 0x00C // 4))
    # (Line 305) bwrite_epd(spriteEPD + 0x0A/4, 0x0A%4, Color);
    EUDTraceLog(305)
    f_bwrite_epd(spriteEPD + 0x0A // 4, 0x0A % 4, Color)
    # (Line 306) }
    # (Line 308) function SetHP(val, modify:TrgModifier) {

@EUDTracedTypedFunc([None, TrgModifier])
def SetHP(val, modify):
    # (Line 309) const cp = getcurpl();
    EUDTraceLog(309)
    cp = f_getcurpl()
    # (Line 310) SetMemoryEPD(user.character[cp] + 0x8 / 4, modify, val * 256);
    # (Line 311) if(MemoryEPD(user.character[cp] + 0x8 / 4, AtLeast, user.maxHP[cp] * 256)) {
    EUDTraceLog(310)
    DoActions(SetMemoryEPD(user.character[cp] + 0x8 // 4, modify, val * 256))
    _t1 = EUDIf()
    EUDTraceLog(311)
    if _t1(MemoryEPD(user.character[cp] + 0x8 // 4, AtLeast, user.maxHP[cp] * 256)):
        # (Line 312) SetMemoryEPD(user.character[cp] + 0x8 / 4, SetTo, user.maxHP[cp] * 256);
        # (Line 313) }
        EUDTraceLog(312)
        DoActions(SetMemoryEPD(user.character[cp] + 0x8 // 4, SetTo, user.maxHP[cp] * 256))
        # (Line 314) }
    EUDEndIf()
    # (Line 316) function SetMaxHP() {

@EUDTracedFunc
def SetMaxHP():
    # (Line 317) const cp = getcurpl();
    EUDTraceLog(317)
    cp = f_getcurpl()
    # (Line 318) SetMemoryEPD(EPD(0x662350) + v.unitNum[cp] * 4, SetTo, user.maxHP[cp] * 256);
    # (Line 319) }
    EUDTraceLog(318)
    DoActions(SetMemoryEPD(EPD(0x662350) + v.unitNum[cp] * 4, SetTo, user.maxHP[cp] * 256))
    # (Line 321) function AllyCheck() {

@EUDTracedFunc
def AllyCheck():
    # (Line 322) if(!MemoryEPD(EPD(0x58D634), Exactly, 16843009) || !MemoryEPD(EPD(0x58D638), Exactly, 65793)) {
    _t1 = EUDIf()
    EUDTraceLog(322)
    if _t1(EUDSCOr()(MemoryEPD(EPD(0x58D634), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D638), Exactly, 65793), neg=True)()):
        # (Line 323) setcurpl(0);
        EUDTraceLog(323)
        f_setcurpl(0)
        # (Line 324) SetAllianceStatus(Force1, Ally);
        # (Line 325) }
        EUDTraceLog(324)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 326) if(!MemoryEPD(EPD(0x58D640), Exactly, 16843009) || !MemoryEPD(EPD(0x58D644), Exactly, 65793)) {
    EUDEndIf()
    _t2 = EUDIf()
    EUDTraceLog(326)
    if _t2(EUDSCOr()(MemoryEPD(EPD(0x58D640), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D644), Exactly, 65793), neg=True)()):
        # (Line 327) setcurpl(1);
        EUDTraceLog(327)
        f_setcurpl(1)
        # (Line 328) SetAllianceStatus(Force1, Ally);
        # (Line 329) }
        EUDTraceLog(328)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 330) if(!MemoryEPD(EPD(0x58D64C), Exactly, 16843009) || !MemoryEPD(EPD(0x58D650), Exactly, 65793)) {
    EUDEndIf()
    _t3 = EUDIf()
    EUDTraceLog(330)
    if _t3(EUDSCOr()(MemoryEPD(EPD(0x58D64C), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D650), Exactly, 65793), neg=True)()):
        # (Line 331) setcurpl(2);
        EUDTraceLog(331)
        f_setcurpl(2)
        # (Line 332) SetAllianceStatus(Force1, Ally);
        # (Line 333) }
        EUDTraceLog(332)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 334) if(!MemoryEPD(EPD(0x58D658), Exactly, 16843009) || !MemoryEPD(EPD(0x58D65C), Exactly, 65793)) {
    EUDEndIf()
    _t4 = EUDIf()
    EUDTraceLog(334)
    if _t4(EUDSCOr()(MemoryEPD(EPD(0x58D658), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D65C), Exactly, 65793), neg=True)()):
        # (Line 335) setcurpl(3);
        EUDTraceLog(335)
        f_setcurpl(3)
        # (Line 336) SetAllianceStatus(Force1, Ally);
        # (Line 337) }
        EUDTraceLog(336)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 338) if(!MemoryEPD(EPD(0x58D664), Exactly, 16843009) || !MemoryEPD(EPD(0x58D668), Exactly, 65793)) {
    EUDEndIf()
    _t5 = EUDIf()
    EUDTraceLog(338)
    if _t5(EUDSCOr()(MemoryEPD(EPD(0x58D664), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D668), Exactly, 65793), neg=True)()):
        # (Line 339) setcurpl(4);
        EUDTraceLog(339)
        f_setcurpl(4)
        # (Line 340) SetAllianceStatus(Force1, Ally);
        # (Line 341) }
        EUDTraceLog(340)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 342) if(!MemoryEPD(EPD(0x58D670), Exactly, 16843009) || !MemoryEPD(EPD(0x58D674), Exactly, 65793)) {
    EUDEndIf()
    _t6 = EUDIf()
    EUDTraceLog(342)
    if _t6(EUDSCOr()(MemoryEPD(EPD(0x58D670), Exactly, 16843009), neg=True)(MemoryEPD(EPD(0x58D674), Exactly, 65793), neg=True)()):
        # (Line 343) setcurpl(5);
        EUDTraceLog(343)
        f_setcurpl(5)
        # (Line 344) SetAllianceStatus(Force1, Ally);
        # (Line 345) }
        EUDTraceLog(344)
        DoActions(SetAllianceStatus(Force1, Ally))
        # (Line 346) }
    EUDEndIf()
