## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import Inventory as inven;
import Inventory as inven
# (Line 2) import Item.Info.Potion as potion;
from Item.Info import Potion as potion
# (Line 3) import Item.Info.Weapon as weapon;
from Item.Info import Weapon as weapon
# (Line 4) import Item.Info.Armor as armor;
from Item.Info import Armor as armor
# (Line 5) import Variable as v;
import Variable as v
# (Line 7) function AddItem(percent, type, index, amount, display);
# (Line 8) function RemoveItem(type, index, amount);
# (Line 9) function CheckEmptySlot();
# (Line 10) function CheckItemSlot(type_, index_);
# (Line 11) function CheckAlreadyHave(type, index);
# (Line 12) function FindItem(type, index, amount);
# (Line 14) function Init() {
@EUDTracedFunc
def Init():
    # (Line 15) potion.SetItemInfo();
    EUDTraceLog(15)
    potion.SetItemInfo()
    # (Line 16) weapon.SetItemInfo();
    EUDTraceLog(16)
    weapon.SetItemInfo()
    # (Line 17) armor.SetItemInfo();
    EUDTraceLog(17)
    armor.SetItemInfo()
    # (Line 18) }
    # (Line 20) function AddItem(percent, type, index, amount, display) {

@EUDTracedFunc
def AddItem(percent, type, index, amount, display):
    # (Line 21) const cp = getcurpl();
    EUDTraceLog(21)
    cp = f_getcurpl()
    # (Line 22) var ran = dwrand() % 10001;
    EUDTraceLog(22)
    ran = EUDVariable()
    ran << (f_dwrand() % 10001)
    # (Line 23) var slot = 0;
    EUDTraceLog(23)
    slot = EUDVariable()
    slot << (0)
    # (Line 24) var name = 0;
    EUDTraceLog(24)
    name = EUDVariable()
    name << (0)
    # (Line 27) if(ran < percent) {
    _t1 = EUDIf()
    EUDTraceLog(27)
    if _t1(ran >= percent, neg=True):
        # (Line 28) if(CheckAlreadyHave(type, index)) {
        _t2 = EUDIf()
        EUDTraceLog(28)
        if _t2(CheckAlreadyHave(type, index)):
            # (Line 29) slot = CheckItemSlot(type, index);
            EUDTraceLog(29)
            slot << (CheckItemSlot(type, index))
            # (Line 30) }
            # (Line 31) else slot = CheckEmptySlot();
        if EUDElse()():
            EUDTraceLog(31)
            slot << (CheckEmptySlot())
            # (Line 32) if(slot == 25) {
        EUDEndIf()
        _t3 = EUDIf()
        EUDTraceLog(32)
        if _t3(slot == 25):
            # (Line 33) v.s.print("\x04인벤토리에 자리가 없습니다");
            EUDTraceLog(33)
            v.s.print("\x04인벤토리에 자리가 없습니다")
            # (Line 34) return;
            EUDTraceLog(34)
            EUDReturn()
            # (Line 35) }
            # (Line 37) const c = inven.Inven.cast(inven.inven[24 * cp + slot]);
        EUDEndIf()
        EUDTraceLog(37)
        c = inven.Inven.cast(inven.inven[24 * cp + slot])
        # (Line 38) if(type == 1) {
        _t4 = EUDIf()
        EUDTraceLog(38)
        if _t4(type == 1):
            # (Line 39) if(index > 5) return;
            _t5 = EUDIf()
            EUDTraceLog(39)
            if _t5(index <= 5, neg=True):
                EUDTraceLog(39)
                EUDReturn()
                # (Line 40) const p = potion.Potion.cast(potion.potionList[index - 1]);
            EUDEndIf()
            EUDTraceLog(40)
            p = potion.Potion.cast(potion.potionList[index - 1])
            # (Line 41) c.type = p.type;
            EUDTraceLog(41)
            _ATTW(c, 'type') << (p.type)
            # (Line 42) c.index = index;
            EUDTraceLog(42)
            _ATTW(c, 'index') << (index)
            # (Line 43) c.name = p.name;
            EUDTraceLog(43)
            _ATTW(c, 'name') << (p.name)
            # (Line 44) c.value1 = p.value;
            EUDTraceLog(44)
            _ATTW(c, 'value1') << (p.value)
            # (Line 45) c.amount += amount;
            EUDTraceLog(45)
            _ATTW(c, 'amount').__iadd__(amount)
            # (Line 46) c.explain = p.explain;
            EUDTraceLog(46)
            _ATTW(c, 'explain') << (p.explain)
            # (Line 47) }
            # (Line 48) else if(type == 2) {
        _t6 = EUDElseIf()
        EUDTraceLog(48)
        if _t6(type == 2):
            # (Line 49) const w = weapon.Weapon.cast(weapon.weaponList[index - 1]);
            EUDTraceLog(49)
            w = weapon.Weapon.cast(weapon.weaponList[index - 1])
            # (Line 50) c.type = w.type;
            EUDTraceLog(50)
            _ATTW(c, 'type') << (w.type)
            # (Line 51) c.index = index;
            EUDTraceLog(51)
            _ATTW(c, 'index') << (index)
            # (Line 52) c.lv = w.lv;
            EUDTraceLog(52)
            _ATTW(c, 'lv') << (w.lv)
            # (Line 53) c.name = w.name;
            EUDTraceLog(53)
            _ATTW(c, 'name') << (w.name)
            # (Line 54) c.amount += amount;
            EUDTraceLog(54)
            _ATTW(c, 'amount').__iadd__(amount)
            # (Line 55) }
            # (Line 56) else if(type == 3) {
        _t7 = EUDElseIf()
        EUDTraceLog(56)
        if _t7(type == 3):
            # (Line 57) if(index > 5) return;
            _t8 = EUDIf()
            EUDTraceLog(57)
            if _t8(index <= 5, neg=True):
                EUDTraceLog(57)
                EUDReturn()
                # (Line 58) const a = armor.Armor.cast(armor.armorList[index - 1]);
            EUDEndIf()
            EUDTraceLog(58)
            a = armor.Armor.cast(armor.armorList[index - 1])
            # (Line 59) c.type = a.type;
            EUDTraceLog(59)
            _ATTW(c, 'type') << (a.type)
            # (Line 60) c.index = index;
            EUDTraceLog(60)
            _ATTW(c, 'index') << (index)
            # (Line 61) c.lv = a.lv;
            EUDTraceLog(61)
            _ATTW(c, 'lv') << (a.lv)
            # (Line 62) c.name = a.name;
            EUDTraceLog(62)
            _ATTW(c, 'name') << (a.name)
            # (Line 63) c.amount += amount;
            EUDTraceLog(63)
            _ATTW(c, 'amount').__iadd__(amount)
            # (Line 64) c.value1 = a.defense;
            EUDTraceLog(64)
            _ATTW(c, 'value1') << (a.defense)
            # (Line 65) }
            # (Line 66) else return;
        if EUDElse()():
            EUDTraceLog(66)
            EUDReturn()
            # (Line 68) if(display == true) {
        EUDEndIf()
        _t9 = EUDIf()
        EUDTraceLog(68)
        if _t9(display == True):
            # (Line 70) v.s.print("\x04[", ptr2s(c.name), "] 을 얻었습니다");
            EUDTraceLog(70)
            v.s.print("\x04[", ptr2s(c.name), "] 을 얻었습니다")
            # (Line 71) }
            # (Line 72) v.textRefresh[cp] = 1;
        EUDEndIf()
        EUDTraceLog(72)
        _ARRW(v.textRefresh, cp) << (1)
        # (Line 73) }
        # (Line 74) }
    EUDEndIf()
    # (Line 76) function RemoveItem(type, index, amount) {

@EUDTracedFunc
def RemoveItem(type, index, amount):
    # (Line 77) const cp = getcurpl();
    EUDTraceLog(77)
    cp = f_getcurpl()
    # (Line 78) const t = cp * 24;
    EUDTraceLog(78)
    t = cp * 24
    # (Line 79) var slot = 0;
    EUDTraceLog(79)
    slot = EUDVariable()
    slot << (0)
    # (Line 82) slot = CheckItemSlot(type, index);
    EUDTraceLog(82)
    slot << (CheckItemSlot(type, index))
    # (Line 85) const c = inven.Inven.cast(inven.inven[t + slot]);
    EUDTraceLog(85)
    c = inven.Inven.cast(inven.inven[t + slot])
    # (Line 88) var name = c.name;
    EUDTraceLog(88)
    name = EUDVariable()
    name << (c.name)
    # (Line 91) if(c.amount < amount) {
    _t1 = EUDIf()
    EUDTraceLog(91)
    if _t1(c.amount >= amount, neg=True):
        # (Line 92) v.s.print("\x08Error");
        EUDTraceLog(92)
        v.s.print("\x08Error")
        # (Line 93) return;
        EUDTraceLog(93)
        EUDReturn()
        # (Line 94) }
        # (Line 96) if(type == 1) {
    EUDEndIf()
    _t2 = EUDIf()
    EUDTraceLog(96)
    if _t2(type == 1):
        # (Line 99) }
        # (Line 100) else if(type == 2) {
        pass
    _t3 = EUDElseIf()
    EUDTraceLog(100)
    if _t3(type == 2):
        # (Line 102) }
        # (Line 103) c.amount -= amount;
        pass
    EUDEndIf()
    EUDTraceLog(103)
    _ATTW(c, 'amount').__isub__(amount)
    # (Line 105) if(c.amount == 0) {
    _t4 = EUDIf()
    EUDTraceLog(105)
    if _t4(c.amount == 0):
        # (Line 106) c.type = 0;
        EUDTraceLog(106)
        _ATTW(c, 'type') << (0)
        # (Line 107) c.index = 0;
        EUDTraceLog(107)
        _ATTW(c, 'index') << (0)
        # (Line 108) c.name = Db("\x05Empty");
        EUDTraceLog(108)
        _ATTW(c, 'name') << (Db("\x05Empty"))
        # (Line 109) c.explain = Db("");
        EUDTraceLog(109)
        _ATTW(c, 'explain') << (Db(""))
        # (Line 110) inven.Sort();
        EUDTraceLog(110)
        inven.Sort()
        # (Line 111) }
        # (Line 112) v.textRefresh[cp] = 1;
    EUDEndIf()
    EUDTraceLog(112)
    _ARRW(v.textRefresh, cp) << (1)
    # (Line 114) }
    # (Line 116) function CheckEmptySlot() {

@EUDTracedFunc
def CheckEmptySlot():
    # (Line 117) const cp = getcurpl();
    EUDTraceLog(117)
    cp = f_getcurpl()
    # (Line 118) const t = cp * 24;
    EUDTraceLog(118)
    t = cp * 24
    # (Line 120) for(var i = 0; i < 24; i++) {
    EUDTraceLog(120)
    i = EUDVariable()
    i << (0)
    _t1 = EUDWhile()
    EUDTraceLog(120)
    if _t1(i >= 24, neg=True):
        def _t2():
            EUDTraceLog(120)
            i.__iadd__(1)
        # (Line 121) const c = inven.Inven.cast(inven.inven[t + i]);
        EUDTraceLog(121)
        c = inven.Inven.cast(inven.inven[t + i])
        # (Line 122) if(c.type == 0 && c.index == 0) {
        _t3 = EUDIf()
        EUDTraceLog(122)
        if _t3(EUDSCAnd()(c.type == 0)(c.index == 0)()):
            # (Line 123) return i;
            EUDTraceLog(123)
            EUDReturn(i)
            # (Line 124) }
            # (Line 125) }
        EUDEndIf()
        # (Line 126) return 25;
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDTraceLog(126)
    EUDReturn(25)
    # (Line 127) }
    # (Line 129) function CheckItemSlot(type_, index_) {

@EUDTracedFunc
def CheckItemSlot(type_, index_):
    # (Line 130) const cp = getcurpl();
    EUDTraceLog(130)
    cp = f_getcurpl()
    # (Line 131) const t = cp * 24;
    EUDTraceLog(131)
    t = cp * 24
    # (Line 132) for(var i = 0; i < 24; i++) {
    EUDTraceLog(132)
    i = EUDVariable()
    i << (0)
    _t1 = EUDWhile()
    EUDTraceLog(132)
    if _t1(i >= 24, neg=True):
        def _t2():
            EUDTraceLog(132)
            i.__iadd__(1)
        # (Line 133) const c = inven.Inven.cast(inven.inven[t + i]);
        EUDTraceLog(133)
        c = inven.Inven.cast(inven.inven[t + i])
        # (Line 134) if(c.type == type_) {
        _t3 = EUDIf()
        EUDTraceLog(134)
        if _t3(c.type == type_):
            # (Line 135) if(c.index == index_) {
            _t4 = EUDIf()
            EUDTraceLog(135)
            if _t4(c.index == index_):
                # (Line 136) return i;
                EUDTraceLog(136)
                EUDReturn(i)
                # (Line 137) }
                # (Line 138) }
            EUDEndIf()
            # (Line 139) }
        EUDEndIf()
        # (Line 140) }
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    # (Line 142) function CheckAlreadyHave(type, index) {

@EUDTracedFunc
def CheckAlreadyHave(type, index):
    # (Line 143) const cp = getcurpl();
    EUDTraceLog(143)
    cp = f_getcurpl()
    # (Line 144) const t = cp * 24;
    EUDTraceLog(144)
    t = cp * 24
    # (Line 145) for(var i = 0; i < 24; i++) {
    EUDTraceLog(145)
    i = EUDVariable()
    i << (0)
    _t1 = EUDWhile()
    EUDTraceLog(145)
    if _t1(i >= 24, neg=True):
        def _t2():
            EUDTraceLog(145)
            i.__iadd__(1)
        # (Line 146) const c = inven.Inven.cast(inven.inven[t + i]);
        EUDTraceLog(146)
        c = inven.Inven.cast(inven.inven[t + i])
        # (Line 147) if(c.type == type && c.index == index) {
        _t3 = EUDIf()
        EUDTraceLog(147)
        if _t3(EUDSCAnd()(c.type == type)(c.index == index)()):
            # (Line 148) return true;
            EUDTraceLog(148)
            EUDReturn(True)
            # (Line 149) }
            # (Line 150) }
        EUDEndIf()
        # (Line 151) return false;
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDTraceLog(151)
    EUDReturn(False)
    # (Line 152) }
    # (Line 154) function FindItem(type, index, amount) {

@EUDTracedFunc
def FindItem(type, index, amount):
    # (Line 155) const cp = getcurpl();
    EUDTraceLog(155)
    cp = f_getcurpl()
    # (Line 156) const t = 24 * cp;
    EUDTraceLog(156)
    t = 24 * cp
    # (Line 157) for(var i = 0; i < 24; i++)
    EUDTraceLog(157)
    i = EUDVariable()
    i << (0)
    _t1 = EUDWhile()
    EUDTraceLog(157)
    if _t1(i >= 24, neg=True):
        def _t2():
            EUDTraceLog(157)
            i.__iadd__(1)
        # (Line 158) {
        # (Line 159) const c = inven.Item_.cast(inven.inven[t + i]);
        EUDTraceLog(159)
        c = inven.Item_.cast(inven.inven[t + i])
        # (Line 160) if(c.type == type && c.index == index && c.amount >= amount)
        _t3 = EUDIf()
        EUDTraceLog(160)
        if _t3(EUDSCAnd()(c.type == type)(c.index == index)(c.amount >= amount)()):
            # (Line 161) {
            # (Line 162) return true;
            EUDTraceLog(162)
            EUDReturn(True)
            # (Line 163) }
            # (Line 164) }
        EUDEndIf()
        # (Line 165) }
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
